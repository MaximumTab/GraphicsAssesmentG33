<html>
	<head>
		<title>The isle</title>
		<style>
			body{
				margin: 0;
			}

			.control-panel {
			  background-color: rgba(255, 255, 255, 0.5); /* Adjust transparency as needed */
			  padding: 10px;
			  border-radius: 10px;
			  align-items: center;
			  display: flex;
			  flex-direction: column;
			}

			#panelWrapper{
				padding: 10px;
				flex-direction: column;
				position: absolute;
				display: flex;
				gap: 10px;
			}
		  
			.control-panel label, 
			.control-panel input[type=range], 
			.control-panel button {
			  width: auto;
			  margin: 5 0;
			  align-self: center;
			  border-radius: 10px;
			  border-color: transparent;
			}

		  </style>
	</head>

	<body>
		<link rel="shortcut icon" href="#">


		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
		</script>
		
		
	<script type="module">

			import * as THREE from 'three';
			import {OrbitControls} from './build/controls/OrbitControls.js';
			//import  {seededRandom} from './build/meth/MathUtils.js';

			var camera, scene, renderer, controls;
		

			init();
			animate();
			onWindowResize();

			function init() {
				//Scene
				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x0762ad);
				var ratio = window.innerWidth / window.innerHeight;
				camera = new THREE.PerspectiveCamera(70, ratio, 0.1, 100000);
				camera.position.set(0, 30, 10); 

				//Renderer
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				//OrbitControls
				controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true; 
				controls.dampingFactor = 0.25;
				controls.screenSpacePanning = false;

				// Add the roundish island to the scene
				const island = createComplexFloatingIsland();
				scene.add(island); // Don't forget to add the island to the scene

				// Lighting
				const light = new THREE.DirectionalLight(0xffffff, 1);
				light.position.set(0, 100, 100);
				scene.add(light);

				const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
				light.position.set(0, -100, 0);
				scene.add(light2);

				const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
				scene.add(ambientLight);

				const cube = createSimpleCube();
				scene.add(cube);

			}

			function createSimpleCube() {
				// Define the geometry for a cube (size of 1x1x1)
				const geometry = new THREE.BoxGeometry(1, 1, 1);

				// Define the material, basic color without lighting
				const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green color

				// Create a mesh with the geometry and material
				const cube = new THREE.Mesh(geometry, material);

				// Return the cube mesh
				return cube;
			}

			
			function createComplexFloatingIsland() {
				// Create an icosahedron geometry as the base for the island
				const baseGeometry = new THREE.IcosahedronGeometry(10, 4); // Radius and detail

				// Access the position attribute of the geometry
				const positions = baseGeometry.attributes.position;
				const verticesCount = positions.count;

				// Temporary vector for manipulating vertex positions
				const vertex = new THREE.Vector3();

				// Compute the max and min height of vertices to scale the displacement accordingly
				let maxHeight = 0;
				let minHeight = Infinity;
				for (let i = 0; i < verticesCount; i++) {
					vertex.fromBufferAttribute(positions, i);
					if (vertex.y > maxHeight) maxHeight = vertex.y;
					if (vertex.y < minHeight) minHeight = vertex.y;
				}
				
				// Set a level where the top of the island should be flattened
				const flattenLevel = maxHeight * 0.5;

				// Modify vertices to create the island shape
				for (let i = 0; i < verticesCount; i++) {
					vertex.fromBufferAttribute(positions, i);

					// Calculate the relative height of the vertex within the island
					const relativeHeight = (vertex.y - minHeight) / (maxHeight - minHeight);

					// Displace vertices outwards more as they are higher up
					const displacement = relativeHeight * 2; // Adjust this factor to affect the "bulge" of the island
					
					vertex.x *= 1 + displacement;
					vertex.z *= 1 + displacement;

					// Flatten the top of the island
					if (vertex.y > flattenLevel) {
						vertex.y = flattenLevel + (vertex.y - flattenLevel) * 0.1;
					}

					// Apply the modified position back to the geometry
					positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
				}

				// Notify Three.js that the position buffer needs to be updated
				positions.needsUpdate = true;

				// Recalculate normals for the lighting after modifying the geometry
				baseGeometry.computeVertexNormals();

				// Create a mesh with the modified geometry and a simple gray material
				const islandMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 }); // Medium gray
				const island = new THREE.Mesh(baseGeometry, islandMaterial);

				// Position the island to float
				island.position.y = 5; // Adjust height as needed

				// Add the island to the scene
				scene.add(island);

				
				
			}

			





			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);
				controls.update();
				renderer.render(scene, camera);
			}

				

		
		</script>
	</body>
</html>
