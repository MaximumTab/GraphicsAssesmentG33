<html>
	<head>
		<title>EpicMountainGenerator</title>
		<style>
			body{
				margin: 0;
			}

			.control-panel {
			  background-color: rgba(255, 255, 255, 0.5); /* Adjust transparency as needed */
			  padding: 10px;
			  border-radius: 10px;
			  align-items: center;
			  display: flex;
			  flex-direction: column;
			}

			#panelWrapper{
				padding: 10px;
				flex-direction: column;
				position: absolute;
				display: flex;
				gap: 10px;
			}
		  
			.control-panel label, 
			.control-panel input[type=range], 
			.control-panel button {
			  width: auto;
			  margin: 5 0;
			  align-self: center;
			  border-radius: 10px;
			  border-color: transparent;
			}

		  </style>
	</head>

	<body>
		<link rel="shortcut icon" href="#">


		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
		</script>
		
		
	<script type="module">

			import * as THREE from 'three';
			import {OrbitControls} from './build/controls/OrbitControls.js';
			//import  {seededRandom} from './build/meth/MathUtils.js';

			var camera, scene, renderer, controls;
		

			init();
			animate();
			onWindowResize();

			function init() {
				//Scene
				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x0762ad);
				var ratio = window.innerWidth / window.innerHeight;
				camera = new THREE.PerspectiveCamera(70, ratio, 0.1, 100000);
				camera.position.set(0, 10, 10); 

				//Renderer
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				//OrbitControls
				controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true; 
				controls.dampingFactor = 0.25;
				controls.screenSpacePanning = false;

				// Add the roundish island to the scene
				const island = createRoundishIsland();
				scene.add(island); // Don't forget to add the island to the scene

				// Lighting
				const light = new THREE.DirectionalLight(0xffffff, 1);
				light.position.set(0, 100, 0);
				scene.add(light);

				const cube = createSimpleCube();
				scene.add(cube);

			}

			function createSimpleCube() {
				// Define the geometry for a cube (size of 1x1x1)
				const geometry = new THREE.BoxGeometry(1, 1, 1);

				// Define the material, basic color without lighting
				const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green color

				// Create a mesh with the geometry and material
				const cube = new THREE.Mesh(geometry, material);

				// Return the cube mesh
				return cube;
			}

			
			function createRoundishIsland() {
				// Start with a Cylinder Geometry, which has a circular top when viewed from above
				const radiusTop = 5; // Radius of the top circle
				const radiusBottom = 0.1; // Almost a point
				const height = 6; // Height of the island
				const radialSegments = 32; // Number of segmented faces around the circumference of the cylinder

				const geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, 1, false);

				// Access the position attribute of the geometry
				const positions = geometry.attributes.position;

				// Flatten the bottom vertices to form a point
				const bottomVertexIndex = []; // Store the indexes of the bottom vertices
				const bottomY = -height * 0.5; // The bottom Y position for the vertices

				for (let i = 0; i < positions.count; i++) {
					const y = positions.getY(i);
					if (y === bottomY) {
						bottomVertexIndex.push(i);
					}
				}

				// Calculate the center point of the bottom vertices
				let bottomCenter = new THREE.Vector3(0, bottomY, 0);
				for (let i of bottomVertexIndex) {
					positions.setXYZ(i, bottomCenter.x, bottomCenter.y, bottomCenter.z);
				}

				positions.needsUpdate = true; // Notify Three.js to update the position buffer

				geometry.computeVertexNormals(); // Update the normals for the lighting

				// Material with flat shading to enhance the low-poly style
				const material = new THREE.MeshPhongMaterial({ color: 0x77ff77, flatShading: true });

				// Create the mesh
				const island = new THREE.Mesh(geometry, material);

				// Adjust the rotation of the mesh so the top is facing upwards
				island.rotation.x = -Math.PI / 2;

				return island;
			}

			





			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);
				controls.update();
				renderer.render(scene, camera);
			}

				

		
		</script>
	</body>
</html>
